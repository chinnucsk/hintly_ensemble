= About this entry

First, thanks to Github for putting on a great contest.

This entry was supposed to be a blend of xlvector and jeremybarnes' solutions, but due to time it ended up being just xlvector's.

Liang Xiang (xlvector) will explain his model shortly, Jeremy's already explained a great deal in his README (read it, it's great!).

== The secret sauce?

More data equals better results.

We also crammed in more heuristics.

== Next steps

Anyone wanting to build on this should probably pay close attention to blending. The algorithms themselves aren't incredibly new, but there's probably low-hanging fruit with neural networks, decision trees (or combinations) for blending ordered and weighted lists.

== Algorithms

=== Item Based KNN

This algo is in knni directory. I use cosine similarity with inverse user frequency to measure item-item similarity.

We also use reponame and language information in measuring item-item similarity, this algo is implemented in knni-all.

=== User Based KNN

This algo is in knnu directory. I use cosine similarity with inverse item frequency to measure user-user similarity.

We also use reponame and language information in measuring user-user similarity, this algo is implemented in knnu-all.

Let's take language information for example, given two user a, b. Let La[i] be the percent of repo which is written in language i user a watch. Then, the language similarity of user a, b can be calculated by cosine(La, Lb).
     
=== Hybrid User/Item KNN
This algo is in knnui directory

=== Removing unlike items
If we want to find the repos a user will watch, we can slove this problem by removing items he/she will not watch. In this way, I use some extremum value to remove unlike items.

For example, given a user u, if the popularity of the most popular repo he/she watch is N. Then, in the recommendation list, we should decent the likeness of the repos which popularity is larger than N. In blending/main.cpp, function userMostPopular do this task.

Further more, we know the date of the repo when it is created. Let T1 be the earliest create date of repos user u watch, and T2 be the latest create date of repos user u watch. Then, we should increase the weight of repos created between T1 and T2. In blending/main.cpp, function postProcessByDate do this task.
          
=== Result Diversity
In the contest, we find users who watch a lot of repos are hard to be predicted. This is because they have diversity interest, therefore, it is hard to cover their interest in only 10 recommendations. In this way, we should let recommendations list include different interest field of users and we have to improve the diversity of recommendations.

This algo is implemented in function diversity() in file blending/main.cpp